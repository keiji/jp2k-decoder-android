        -:    0:Source:wrapper.c
        -:    0:Graph:test_wrapper_cov-test_wrapper.gcno
        -:    0:Data:test_wrapper_cov-test_wrapper.gcda
        -:    0:Runs:2
        -:    1:#include <openjpeg.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <stdint.h>
        -:    4:#include <string.h>
        -:    5:#include <emscripten.h>
        -:    6:
        -:    7:// Error Codes
        -:    8:#define ERR_NONE 0
        -:    9:#define ERR_HEADER -1
        -:   10:#define ERR_INPUT_DATA_SIZE -2
        -:   11:#define ERR_PIXEL_DATA_SIZE -3
        -:   12:#define ERR_DECODE -4
        -:   13:#define ERR_DECODER_SETUP -5
        -:   14:#define ERR_REGION_OUT_OF_BOUNDS -6
        -:   15:
        -:   16:#define MIN_INPUT_SIZE 12
        -:   17:
        -:   18:// Color Formats
        -:   19:#define COLOR_FORMAT_RGB565 565
        -:   20:#define COLOR_FORMAT_ARGB8888 8888
        -:   21:
        -:   22:int last_error = ERR_NONE;
        -:   23:
        -:   24:EMSCRIPTEN_KEEPALIVE
function getLastError called 2 returned 100% blocks executed 100%
        2:   25:int getLastError() {
        2:   26:    return last_error;
        2:   26-block  0
unconditional  0 taken 2
        -:   27:}
        -:   28:
        -:   29:typedef struct {
        -:   30:    OPJ_BYTE* data;
        -:   31:    OPJ_SIZE_T size;
        -:   32:    OPJ_SIZE_T offset;
        -:   33:} opj_buffer_info_t;
        -:   34:
function opj_read_from_buffer called 6 returned 100% blocks executed 100%
        6:   35:static OPJ_SIZE_T opj_read_from_buffer(void* p_buffer, OPJ_SIZE_T p_nb_bytes, void* p_user_data) {
        6:   36:    opj_buffer_info_t* p_info = (opj_buffer_info_t*)p_user_data;
        6:   37:    OPJ_SIZE_T l_nb_read = p_nb_bytes;
        6:   38:    if (p_info->offset >= p_info->size) return (OPJ_SIZE_T)-1;
        6:   38-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 4
        2:   38-block  1
unconditional  2 taken 2
        4:   39:    if (p_info->offset + p_nb_bytes > p_info->size) l_nb_read = p_info->size - p_info->offset;
        4:   39-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:   39-block  1
unconditional  2 taken 2
        4:   40:    memcpy(p_buffer, p_info->data + p_info->offset, l_nb_read);
        4:   41:    p_info->offset += l_nb_read;
        4:   42:    return l_nb_read;
        4:   42-block  0
unconditional  0 taken 4
        -:   43:}
        -:   44:
function get_codec_format called 86 returned 100% blocks executed 100%
       86:   45:static OPJ_CODEC_FORMAT get_codec_format(uint8_t* data, uint32_t data_len) {
       86:   46:    if (data_len >= 4 &&
       86:   46-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 0
       86:   47:        data[0] == 0x00 &&
       86:   47-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 0
       86:   48:        data[1] == 0x00 &&
       86:   48-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 0
       86:   49:        data[2] == 0x00 &&
       86:   49-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 0
       86:   50:        data[3] == 0x0C) {
       86:   50-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 84
        2:   51:        return OPJ_CODEC_JP2;
        2:   51-block  0
unconditional  0 taken 2
        -:   52:    }
       84:   53:    return OPJ_CODEC_J2K;
       84:   53-block  0
unconditional  0 taken 84
        -:   54:}
        -:   55:
function create_decoder called 86 returned 100% blocks executed 100%
       86:   56:static opj_codec_t* create_decoder(OPJ_CODEC_FORMAT format) {
       86:   57:    opj_codec_t* l_codec = opj_create_decompress(format);
       86:   57-block  0
call    0 returned 86
       86:   58:    if (!l_codec) return NULL;
branch  0 taken 4 (fallthrough)
branch  1 taken 82
        4:   58-block  0
unconditional  2 taken 4
        -:   59:
        -:   60:    opj_dparameters_t l_params;
       82:   61:    opj_set_default_decoder_parameters(&l_params);
       82:   61-block  0
call    0 returned 82
       82:   62:    if (!opj_setup_decoder(l_codec, &l_params)) {
call    0 returned 82
branch  1 taken 2 (fallthrough)
branch  2 taken 80
        2:   63:        opj_destroy_codec(l_codec);
        2:   63-block  0
call    0 returned 2
        2:   64:        return NULL;
unconditional  0 taken 2
        -:   65:    }
       80:   66:    return l_codec;
       80:   66-block  0
unconditional  0 taken 80
        -:   67:}
        -:   68:
function create_mem_stream called 80 returned 100% blocks executed 100%
       80:   69:static opj_stream_t* create_mem_stream(opj_buffer_info_t* buffer_info, uint32_t data_len) {
       80:   70:    opj_stream_t* l_stream = opj_stream_default_create(OPJ_TRUE);
       80:   70-block  0
call    0 returned 80
       80:   71:    opj_stream_set_read_function(l_stream, opj_read_from_buffer);
call    0 returned 80
       80:   72:    opj_stream_set_user_data(l_stream, buffer_info, NULL);
call    0 returned 80
       80:   73:    opj_stream_set_user_data_length(l_stream, data_len);
call    0 returned 80
       80:   74:    return l_stream;
unconditional  0 taken 80
        -:   75:}
        -:   76:
function decode_internal called 78 returned 100% blocks executed 100%
       78:   77:static opj_image_t* decode_internal(uint8_t* data, uint32_t data_len, OPJ_CODEC_FORMAT format, uint32_t max_pixels, double x0, double y0, double x1, double y1, int use_ratio) {
       78:   78:    last_error = ERR_NONE;
        -:   79:
       78:   80:    opj_buffer_info_t buffer_info = {data, data_len, 0};
        -:   81:
       78:   82:    opj_codec_t* l_codec = create_decoder(format);
       78:   82-block  0
call    0 returned 78
       78:   83:    if (!l_codec) {
branch  0 taken 4 (fallthrough)
branch  1 taken 74
        4:   84:        last_error = ERR_DECODER_SETUP;
        4:   85:        return NULL;
        4:   85-block  0
unconditional  0 taken 4
        -:   86:    }
        -:   87:
       74:   88:    opj_stream_t* l_stream = create_mem_stream(&buffer_info, data_len);
       74:   88-block  0
call    0 returned 74
        -:   89:
       74:   90:    opj_image_t* l_image = NULL;
       74:   91:    if (!opj_read_header(l_stream, l_codec, &l_image)) {
call    0 returned 74
branch  1 taken 6 (fallthrough)
branch  2 taken 68
        6:   92:        last_error = ERR_HEADER;
        6:   92-block  0
unconditional  0 taken 6
        -:   93:    } else {
       68:   94:        uint32_t width = l_image->x1 - l_image->x0;
       68:   95:        uint32_t height = l_image->y1 - l_image->y0;
        -:   96:
        -:   97:        uint32_t ux0, uy0, ux1, uy1;
       68:   98:        if (use_ratio) {
       68:   98-block  0
branch  0 taken 12 (fallthrough)
branch  1 taken 56
       12:   99:            ux0 = (uint32_t)(width * x0);
       12:  100:            uy0 = (uint32_t)(height * y0);
       12:  101:            ux1 = (uint32_t)(width * x1);
       12:  102:            uy1 = (uint32_t)(height * y1);
       12:  103:            if (ux1 > width) ux1 = width;
       12:  103-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        4:  103-block  1
unconditional  2 taken 4
       12:  104:            if (uy1 > height) uy1 = height;
       12:  104-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 8
        4:  104-block  1
unconditional  2 taken 4
        -:  105:        } else {
       56:  106:            ux0 = (uint32_t)x0;
       56:  107:            uy0 = (uint32_t)y0;
       56:  108:            ux1 = (uint32_t)x1;
       56:  109:            uy1 = (uint32_t)y1;
       56:  109-block  0
unconditional  0 taken 56
        -:  110:        }
        -:  111:
        -:  112:        // Check bounds if partial decoding is requested (x1 > 0 or y1 > 0)
        -:  113:        // If x1 and y1 are 0, we assume full decode (no crop)
        -:  114:        // Note: For ratio, x1/y1 will be > 0 if valid ratio passed.
        -:  115:        // We need to handle 0,0,0,0 ratio as full decode too?
        -:  116:        // Usually ratio 0.0 to 1.0 means 0 to width.
        -:  117:        // If user passes 0,0,0,0 as ratio, it means empty region?
        -:  118:        // But the previous API used 0,0,0,0 as 'full decode'.
        -:  119:        // If use_ratio is true, we expect valid ratios.
        -:  120:        // However, if we want full decode via ratio, we'd pass 0.0, 0.0, 1.0, 1.0.
        -:  121:        // Let's stick to: if use_ratio is false, 0,0,0,0 means full.
        -:  122:        // If use_ratio is true, 0,0,0,0 -> ux0=0, uy0=0, ux1=0, uy1=0 -> is_partial=0 -> full decode.
        -:  123:        // So it works out.
        -:  124:
       68:  125:        int is_partial = (ux1 != 0 || uy1 != 0);
       68:  125-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 58
       10:  125-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 10
       58:  125-block  2
unconditional  4 taken 58
       10:  125-block  3
unconditional  5 taken 10
       68:  126:        int bounds_ok = 1;
        -:  127:
       68:  128:        if (is_partial) {
       68:  128-block  0
branch  0 taken 58 (fallthrough)
branch  1 taken 10
       58:  129:             if (ux0 < l_image->x0 || uy0 < l_image->y0 || ux1 > l_image->x1 || uy1 > l_image->y1 || ux0 >= ux1 || uy0 >= uy1) {
       58:  129-block  0
branch  0 taken 58 (fallthrough)
branch  1 taken 0
       58:  129-block  1
branch  2 taken 58 (fallthrough)
branch  3 taken 0
       58:  129-block  2
branch  4 taken 48 (fallthrough)
branch  5 taken 10
       48:  129-block  3
branch  6 taken 40 (fallthrough)
branch  7 taken 8
       40:  129-block  4
branch  8 taken 28 (fallthrough)
branch  9 taken 12
       28:  129-block  5
branch 10 taken 4 (fallthrough)
branch 11 taken 24
       34:  130:                 bounds_ok = 0;
       34:  130-block  0
unconditional  0 taken 34
        -:  131:             } else {
       24:  132:                 if (!opj_set_decode_area(l_codec, l_image, ux0, uy0, ux1, uy1)) {
       24:  132-block  0
call    0 returned 24
branch  1 taken 2 (fallthrough)
branch  2 taken 22
        -:  133:                     // Should not happen if bounds are ok, but safety check
        2:  134:                     bounds_ok = 0;
        2:  134-block  0
unconditional  0 taken 2
        -:  135:                 }
        -:  136:             }
        -:  137:        }
        -:  138:
       68:  139:        if (!bounds_ok) {
       68:  139-block  0
branch  0 taken 36 (fallthrough)
branch  1 taken 32
       36:  140:            last_error = ERR_REGION_OUT_OF_BOUNDS;
       36:  141:            opj_image_destroy(l_image);
       36:  141-block  0
call    0 returned 36
       36:  142:            l_image = NULL;
unconditional  0 taken 36
       36:  143:        } else if (max_pixels > 0 && ((uint64_t)width * height) > max_pixels) {
       32:  143-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 26
        6:  143-block  1
branch  2 taken 4 (fallthrough)
branch  3 taken 2
        4:  143-block  2
unconditional  4 taken 4
        4:  144:            uint32_t output_width = is_partial ? (ux1 - ux0) : width;
        4:  144-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  144-block  1
unconditional  2 taken 2
        2:  144-block  2
unconditional  3 taken 2
        4:  145:            uint32_t output_height = is_partial ? (uy1 - uy0) : height;
        4:  145-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  145-block  1
unconditional  2 taken 2
        2:  145-block  2
unconditional  3 taken 2
        -:  146:
        4:  147:            if (((uint64_t)output_width * output_height) > max_pixels) {
        4:  147-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  148:                last_error = ERR_PIXEL_DATA_SIZE;
        2:  149:                opj_image_destroy(l_image);
        2:  149-block  0
call    0 returned 2
        2:  150:                l_image = NULL;
unconditional  0 taken 2
        2:  151:            } else if (!opj_decode(l_codec, l_stream, l_image)) {
        2:  151-block  0
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2:  152:                last_error = ERR_DECODE;
        2:  153:                opj_image_destroy(l_image);
        2:  153-block  0
call    0 returned 2
        2:  154:                l_image = NULL;
unconditional  0 taken 2
        -:  155:            }
       28:  156:        } else if (!opj_decode(l_codec, l_stream, l_image)) {
       28:  156-block  0
call    0 returned 28
branch  1 taken 20 (fallthrough)
branch  2 taken 8
       20:  157:            last_error = ERR_DECODE;
       20:  158:            opj_image_destroy(l_image);
       20:  158-block  0
call    0 returned 20
       20:  159:            l_image = NULL;
unconditional  0 taken 20
        -:  160:        }
        -:  161:    }
       74:  162:    opj_stream_destroy(l_stream);
       74:  162-block  0
call    0 returned 74
       74:  163:    opj_destroy_codec(l_codec);
call    0 returned 74
        -:  164:
       74:  165:    return l_image;
unconditional  0 taken 74
        -:  166:}
        -:  167:
function decode_opj_common called 88 returned 100% blocks executed 100%
       88:  168:static opj_image_t* decode_opj_common(uint8_t* data, uint32_t data_len, uint32_t max_pixels, uint32_t max_heap_size, int color_format, double x0, double y0, double x1, double y1, int use_ratio) {
       88:  169:    uint32_t divider = (color_format == COLOR_FORMAT_RGB565) ? 2 : 4;
       88:  169-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 82
        6:  169-block  1
unconditional  2 taken 6
       82:  169-block  2
unconditional  3 taken 82
       88:  170:    uint32_t max_input_size = max_heap_size / divider;
        -:  171:
       88:  172:    if (!data || data_len < MIN_INPUT_SIZE || data_len > max_input_size) {
       88:  172-block  0
branch  0 taken 86 (fallthrough)
branch  1 taken 2
       86:  172-block  1
branch  2 taken 82 (fallthrough)
branch  3 taken 4
       82:  172-block  2
branch  4 taken 4 (fallthrough)
branch  5 taken 78
       10:  173:        last_error = ERR_INPUT_DATA_SIZE;
       10:  174:        return NULL;
       10:  174-block  0
unconditional  0 taken 10
        -:  175:    }
        -:  176:
       78:  177:    OPJ_CODEC_FORMAT format = get_codec_format(data, data_len);
       78:  177-block  0
call    0 returned 78
       78:  178:    return decode_internal(data, data_len, format, max_pixels, x0, y0, x1, y1, use_ratio);
call    0 returned 78
unconditional  1 taken 78
        -:  179:}
        -:  180:
function get_alpha_component called 18 returned 100% blocks executed 100%
       18:  181:static int32_t* get_alpha_component(opj_image_t* image) {
       18:  182:    if (image->numcomps <= 3) return NULL;
       18:  182-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 12
        6:  182-block  1
unconditional  2 taken 6
       60:  183:    for (uint32_t i = 0; i < image->numcomps; i++) {
       12:  183-block  0
unconditional  0 taken 12
       48:  183-block  1
unconditional  1 taken 48
       60:  183-block  2
branch  2 taken 50
branch  3 taken 10 (fallthrough)
       50:  184:        if (image->comps[i].alpha != 0) return image->comps[i].data;
       50:  184-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 48
        2:  184-block  1
unconditional  2 taken 2
        -:  185:    }
       10:  186:    return image->comps[3].data;
       10:  186-block  0
unconditional  0 taken 10
        -:  187:}
        -:  188:
function write_headers_argb8888 called 14 returned 100% blocks executed 100%
       14:  189:static void write_headers_argb8888(uint8_t* buffer, uint32_t file_size, uint32_t width, uint32_t height) {
       14:  190:    uint32_t bmp_header_size = 14;
       14:  191:    uint32_t dib_header_size = 40;
       14:  192:    uint32_t offset = bmp_header_size + dib_header_size;
        -:  193:
        -:  194:    // BMP Header
       14:  195:    buffer[0] = 0x42; // 'B'
       14:  196:    buffer[1] = 0x4D; // 'M'
       14:  197:    memcpy(&buffer[2], &file_size, 4);
       14:  198:    uint32_t reserved = 0;
       14:  199:    memcpy(&buffer[6], &reserved, 4);
       14:  200:    memcpy(&buffer[10], &offset, 4);
        -:  201:
        -:  202:    // DIB Header (BITMAPINFOHEADER)
       14:  203:    memcpy(&buffer[14], &dib_header_size, 4);
       14:  204:    memcpy(&buffer[18], &width, 4);
       14:  205:    int32_t neg_height = -(int32_t)height; // Top-down
       14:  206:    memcpy(&buffer[22], &neg_height, 4);
       14:  207:    uint16_t planes = 1;
       14:  208:    memcpy(&buffer[26], &planes, 2);
       14:  209:    uint16_t bpp = 32;
       14:  210:    memcpy(&buffer[28], &bpp, 2);
       14:  211:    uint32_t compression = 0; // BI_RGB
       14:  212:    memcpy(&buffer[30], &compression, 4);
       14:  213:    uint32_t image_size = 0; // Can be 0 for BI_RGB
       14:  214:    memcpy(&buffer[34], &image_size, 4);
       14:  215:    int32_t resolution = 0;
       14:  216:    memcpy(&buffer[38], &resolution, 4);
       14:  217:    memcpy(&buffer[42], &resolution, 4);
       14:  218:    uint32_t colors = 0;
       14:  219:    memcpy(&buffer[46], &colors, 4);
       14:  220:    memcpy(&buffer[50], &colors, 4);
       14:  221:}
        -:  222:
function write_headers_rgb565 called 6 returned 100% blocks executed 100%
        6:  223:static void write_headers_rgb565(uint8_t* buffer, uint32_t file_size, uint32_t width, uint32_t height) {
        6:  224:    uint32_t bmp_header_size = 14;
        6:  225:    uint32_t dib_header_size = 40;
        6:  226:    uint32_t mask_size = 12; // 3 * 4 bytes for bitfields
        6:  227:    uint32_t offset = bmp_header_size + dib_header_size + mask_size;
        -:  228:
        -:  229:    // BMP Header
        6:  230:    buffer[0] = 0x42;
        6:  231:    buffer[1] = 0x4D;
        6:  232:    memcpy(&buffer[2], &file_size, 4);
        6:  233:    uint32_t reserved = 0;
        6:  234:    memcpy(&buffer[6], &reserved, 4);
        6:  235:    memcpy(&buffer[10], &offset, 4);
        -:  236:
        -:  237:    // DIB Header
        6:  238:    memcpy(&buffer[14], &dib_header_size, 4);
        6:  239:    memcpy(&buffer[18], &width, 4);
        6:  240:    int32_t neg_height = -(int32_t)height;
        6:  241:    memcpy(&buffer[22], &neg_height, 4);
        6:  242:    uint16_t planes = 1;
        6:  243:    memcpy(&buffer[26], &planes, 2);
        6:  244:    uint16_t bpp = 16;
        6:  245:    memcpy(&buffer[28], &bpp, 2);
        6:  246:    uint32_t compression = 3; // BI_BITFIELDS
        6:  247:    memcpy(&buffer[30], &compression, 4);
        6:  248:    uint32_t image_size = 0;
        6:  249:    memcpy(&buffer[34], &image_size, 4);
        6:  250:    int32_t resolution = 0;
        6:  251:    memcpy(&buffer[38], &resolution, 4);
        6:  252:    memcpy(&buffer[42], &resolution, 4);
        6:  253:    uint32_t colors = 0;
        6:  254:    memcpy(&buffer[46], &colors, 4);
        6:  255:    memcpy(&buffer[50], &colors, 4);
        -:  256:
        -:  257:    // Color Masks (Red, Green, Blue)
        -:  258:    // 565 format: R(5) G(6) B(5)
        -:  259:    // Masks are usually written as DWORDs in R, G, B order
        6:  260:    uint32_t r_mask = 0xF800;
        6:  261:    uint32_t g_mask = 0x07E0;
        6:  262:    uint32_t b_mask = 0x001F;
        6:  263:    memcpy(&buffer[54], &r_mask, 4);
        6:  264:    memcpy(&buffer[58], &g_mask, 4);
        6:  265:    memcpy(&buffer[62], &b_mask, 4);
        6:  266:}
        -:  267:
function convert_image_to_bmp called 26 returned 100% blocks executed 100%
       26:  268:static uint8_t* convert_image_to_bmp(opj_image_t* image, int color_format) {
       26:  269:    uint32_t width = image->x1 - image->x0;
       26:  270:    uint32_t height = image->y1 - image->y0;
        -:  271:
       26:  272:    if (image->numcomps < 1) {
       26:  272-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 24
        2:  273:        last_error = ERR_DECODE;
        2:  274:        return NULL;
        2:  274-block  0
unconditional  0 taken 2
        -:  275:    }
        -:  276:
       24:  277:    int32_t* r_data = NULL;
       24:  278:    int32_t* g_data = NULL;
       24:  279:    int32_t* b_data = NULL;
       24:  280:    int32_t* a_data = NULL;
        -:  281:
       24:  282:    if (image->numcomps == 1) {
       24:  282-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 20
        4:  283:        r_data = image->comps[0].data;
        4:  284:        g_data = image->comps[0].data;
        4:  285:        b_data = image->comps[0].data;
        4:  285-block  0
unconditional  0 taken 4
       20:  286:    } else if (image->numcomps == 2) {
       20:  286-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 18
        2:  287:        r_data = image->comps[0].data;
        2:  288:        g_data = image->comps[0].data;
        2:  289:        b_data = image->comps[0].data;
        2:  290:        if (image->comps[1].alpha != 0) {
        2:  290-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  291:            a_data = image->comps[1].data;
        2:  291-block  0
unconditional  0 taken 2
        -:  292:        }
        -:  293:    } else {
       18:  294:        r_data = image->comps[0].data;
       18:  295:        g_data = image->comps[1].data;
       18:  296:        b_data = image->comps[2].data;
       18:  297:        a_data = get_alpha_component(image);
       18:  297-block  0
call    0 returned 18
unconditional  1 taken 18
        -:  298:    }
        -:  299:
       24:  300:    uint8_t* bmp_buffer = NULL;
        -:  301:
       24:  302:    if (color_format == COLOR_FORMAT_RGB565) {
       24:  302-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 16
        -:  303:        // RGB565: 2 bytes per pixel. Rows padded to 4 bytes.
        8:  304:        uint32_t row_bytes = (width * 2 + 3) & ~3;
        8:  305:        uint32_t pixel_data_size = row_bytes * height;
        8:  306:        uint32_t header_size = 14 + 40 + 12; // Header + DIB + Masks
        8:  307:        uint32_t file_size = header_size + pixel_data_size;
        -:  308:
        8:  309:        bmp_buffer = (uint8_t*)malloc(file_size);
        8:  309-block  0
call    0 returned 8
        8:  310:        if (!bmp_buffer) {
branch  0 taken 2 (fallthrough)
branch  1 taken 6
        2:  311:            last_error = ERR_DECODE;
        2:  312:            return NULL;
        2:  312-block  0
unconditional  0 taken 2
        -:  313:        }
        -:  314:
        6:  315:        write_headers_rgb565(bmp_buffer, file_size, width, height);
        6:  315-block  0
call    0 returned 6
        -:  316:
        6:  317:        uint8_t* ptr = bmp_buffer + header_size;
       32:  318:        for (uint32_t y = 0; y < height; y++) {
unconditional  0 taken 6
       32:  318-block  0
branch  1 taken 26
branch  2 taken 6
       26:  319:            uint16_t* row_ptr = (uint16_t*)ptr;
      238:  320:            for (uint32_t x = 0; x < width; x++) {
       26:  320-block  0
unconditional  0 taken 26
      238:  320-block  1
branch  1 taken 212
branch  2 taken 26 (fallthrough)
      212:  321:                uint32_t idx = y * width + x;
      212:  322:                uint16_t r = ((uint16_t)r_data[idx] >> 3) & 0x1F;
      212:  323:                uint16_t g = ((uint16_t)g_data[idx] >> 2) & 0x3F;
      212:  324:                uint16_t b = ((uint16_t)b_data[idx] >> 3) & 0x1F;
      212:  325:                row_ptr[x] = (r << 11) | (g << 5) | b;
      212:  325-block  0
unconditional  0 taken 212
        -:  326:            }
       26:  327:            ptr += row_bytes;
       26:  327-block  0
unconditional  0 taken 26
        -:  328:        }
        -:  329:
        -:  330:    } else {
        -:  331:        // ARGB8888: 4 bytes per pixel. Rows always aligned to 4.
       16:  332:        uint32_t row_bytes = width * 4;
       16:  333:        uint32_t pixel_data_size = row_bytes * height;
       16:  334:        uint32_t header_size = 14 + 40;
       16:  335:        uint32_t file_size = header_size + pixel_data_size;
        -:  336:
       16:  337:        bmp_buffer = (uint8_t*)malloc(file_size);
       16:  337-block  0
call    0 returned 16
       16:  338:        if (!bmp_buffer) {
branch  0 taken 2 (fallthrough)
branch  1 taken 14
        2:  339:            last_error = ERR_DECODE;
        2:  340:            return NULL;
        2:  340-block  0
unconditional  0 taken 2
        -:  341:        }
        -:  342:
       14:  343:        write_headers_argb8888(bmp_buffer, file_size, width, height);
       14:  343-block  0
call    0 returned 14
        -:  344:
       14:  345:        uint8_t* ptr = bmp_buffer + header_size;
       14:  346:        if (a_data) {
branch  0 taken 12 (fallthrough)
branch  1 taken 2
    40224:  347:            for (uint32_t i = 0; i < width * height; i++) {
       12:  347-block  0
unconditional  0 taken 12
    40224:  347-block  1
branch  1 taken 40212
branch  2 taken 12
    40212:  348:                *ptr++ = (uint8_t)b_data[i];
    40212:  349:                *ptr++ = (uint8_t)g_data[i];
    40212:  350:                *ptr++ = (uint8_t)r_data[i];
    40212:  351:                *ptr++ = (uint8_t)a_data[i];
    40212:  351-block  0
unconditional  0 taken 40212
        -:  352:            }
        -:  353:        } else {
        6:  354:            for (uint32_t i = 0; i < width * height; i++) {
        2:  354-block  0
unconditional  0 taken 2
        6:  354-block  1
branch  1 taken 4
branch  2 taken 2 (fallthrough)
        4:  355:                *ptr++ = (uint8_t)b_data[i];
        4:  356:                *ptr++ = (uint8_t)g_data[i];
        4:  357:                *ptr++ = (uint8_t)r_data[i];
        4:  358:                *ptr++ = 0xFF;
        4:  358-block  0
unconditional  0 taken 4
        -:  359:            }
        -:  360:        }
        -:  361:    }
       20:  362:    return bmp_buffer;
       20:  362-block  0
unconditional  0 taken 20
        -:  363:}
        -:  364:
        -:  365:EMSCRIPTEN_KEEPALIVE
function decodeToBmp called 76 returned 100% blocks executed 100%
       76:  366:uint8_t* decodeToBmp(uint8_t* data, uint32_t data_len, uint32_t max_pixels, uint32_t max_heap_size, int color_format, uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1) {
       76:  367:    opj_image_t* image = decode_opj_common(data, data_len, max_pixels, max_heap_size, color_format, (double)x0, (double)y0, (double)x1, (double)y1, 0);
       76:  367-block  0
call    0 returned 76
       76:  368:    if (!image) return NULL;
branch  0 taken 72 (fallthrough)
branch  1 taken 4
       72:  368-block  0
unconditional  2 taken 72
        -:  369:
        4:  370:    uint8_t* bmp_buffer = convert_image_to_bmp(image, color_format);
        4:  370-block  0
call    0 returned 4
        -:  371:
        4:  372:    opj_image_destroy(image);
call    0 returned 4
        4:  373:    return bmp_buffer;
unconditional  0 taken 4
        -:  374:}
        -:  375:
        -:  376:EMSCRIPTEN_KEEPALIVE
function decodeToBmpWithRatio called 12 returned 100% blocks executed 100%
       12:  377:uint8_t* decodeToBmpWithRatio(uint8_t* data, uint32_t data_len, uint32_t max_pixels, uint32_t max_heap_size, int color_format, double x0, double y0, double x1, double y1) {
       12:  378:    opj_image_t* image = decode_opj_common(data, data_len, max_pixels, max_heap_size, color_format, x0, y0, x1, y1, 1);
       12:  378-block  0
call    0 returned 12
       12:  379:    if (!image) return NULL;
branch  0 taken 8 (fallthrough)
branch  1 taken 4
        8:  379-block  0
unconditional  2 taken 8
        -:  380:
        4:  381:    uint8_t* bmp_buffer = convert_image_to_bmp(image, color_format);
        4:  381-block  0
call    0 returned 4
        -:  382:
        4:  383:    opj_image_destroy(image);
call    0 returned 4
        4:  384:    return bmp_buffer;
unconditional  0 taken 4
        -:  385:}
        -:  386:
        -:  387:EMSCRIPTEN_KEEPALIVE
function getSize called 12 returned 100% blocks executed 100%
       12:  388:uint32_t* getSize(uint8_t* data, uint32_t data_len) {
       12:  389:    last_error = ERR_NONE;
       12:  390:    if (!data || data_len < MIN_INPUT_SIZE) {
       12:  390-block  0
branch  0 taken 10 (fallthrough)
branch  1 taken 2
       10:  390-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 8
        4:  391:        last_error = ERR_INPUT_DATA_SIZE;
        4:  392:        return NULL;
        4:  392-block  0
unconditional  0 taken 4
        -:  393:    }
        -:  394:
        8:  395:    opj_buffer_info_t buffer_info = {data, data_len, 0};
        -:  396:
        8:  397:    OPJ_CODEC_FORMAT format = get_codec_format(data, data_len);
        8:  397-block  0
call    0 returned 8
        -:  398:
        8:  399:    opj_codec_t* l_codec = create_decoder(format);
call    0 returned 8
        8:  400:    if (!l_codec) {
branch  0 taken 2 (fallthrough)
branch  1 taken 6
        2:  401:        last_error = ERR_DECODER_SETUP;
        2:  402:        return NULL;
        2:  402-block  0
unconditional  0 taken 2
        -:  403:    }
        -:  404:
        6:  405:    opj_stream_t* l_stream = create_mem_stream(&buffer_info, data_len);
        6:  405-block  0
call    0 returned 6
        -:  406:
        6:  407:    opj_image_t* l_image = NULL;
        6:  408:    uint32_t* result = NULL;
        -:  409:
        6:  410:    if (!opj_read_header(l_stream, l_codec, &l_image)) {
call    0 returned 6
branch  1 taken 2 (fallthrough)
branch  2 taken 4
        2:  411:        last_error = ERR_HEADER;
        2:  411-block  0
unconditional  0 taken 2
        -:  412:    } else {
        4:  413:        uint32_t width = l_image->x1 - l_image->x0;
        4:  414:        uint32_t height = l_image->y1 - l_image->y0;
        -:  415:
        4:  416:        result = (uint32_t*)malloc(2 * sizeof(uint32_t));
        4:  416-block  0
call    0 returned 4
        4:  417:        if (result) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:  418:            result[0] = width;
        2:  419:            result[1] = height;
        2:  419-block  0
unconditional  0 taken 2
        -:  420:        } else {
        2:  421:            last_error = ERR_DECODE;
        2:  421-block  0
unconditional  0 taken 2
        -:  422:        }
        4:  423:        opj_image_destroy(l_image);
        4:  423-block  0
call    0 returned 4
unconditional  1 taken 4
        -:  424:    }
        -:  425:
        6:  426:    opj_stream_destroy(l_stream);
        6:  426-block  0
call    0 returned 6
        6:  427:    opj_destroy_codec(l_codec);
call    0 returned 6
        -:  428:
        6:  429:    return result;
unconditional  0 taken 6
        -:  430:}
