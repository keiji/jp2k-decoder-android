        -:    0:Source:test/test_wrapper.c
        -:    0:Graph:test_wrapper_cov-test_wrapper.gcno
        -:    0:Data:test_wrapper_cov-test_wrapper.gcda
        -:    0:Runs:2
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include "emscripten.h"
        -:    5:
        -:    6:// Malloc hooking for testing
        -:    7:int stub_should_malloc_succeed = 1;
        -:    8:
function my_malloc called 28 returned 100% blocks executed 100%
       28:    9:void* my_malloc(size_t size) {
       28:   10:    if (!stub_should_malloc_succeed) return NULL;
       28:   10-block  0
branch  0 taken 6 (fallthrough)
branch  1 taken 22
        6:   10-block  1
unconditional  2 taken 6
       22:   11:    return malloc(size);
       22:   11-block  0
unconditional  0 taken 22
        -:   12:}
        -:   13:
function my_free called 0 returned 0% blocks executed 0%
    #####:   14:void my_free(void* ptr) {
    #####:   15:    free(ptr);
    #####:   16:}
        -:   17:
        -:   18:#define malloc my_malloc
        -:   19:#define free my_free
        -:   20:
        -:   21:// Include wrapper.c to access static functions
        -:   22:// This is a bit hacky but effective for unit testing static functions
        -:   23:#include "../wrapper.c"
        -:   24:
        -:   25:#undef malloc
        -:   26:#undef free
        -:   27:
        -:   28:// Helper to create a mock opj_image_t
function create_mock_image called 16 returned 100% blocks executed 100%
       16:   29:opj_image_t* create_mock_image(uint32_t width, uint32_t height, int numcomps, int with_alpha) {
       16:   30:    opj_image_t* image = (opj_image_t*)calloc(1, sizeof(opj_image_t));
       16:   31:    image->x0 = 0;
       16:   32:    image->y0 = 0;
       16:   33:    image->x1 = width;
       16:   34:    image->y1 = height;
       16:   35:    image->numcomps = numcomps;
       16:   36:    image->comps = (opj_image_comp_t*)calloc(numcomps, sizeof(opj_image_comp_t));
        -:   37:
       58:   38:    for (int i = 0; i < numcomps; i++) {
       16:   38-block  0
unconditional  0 taken 16
       58:   38-block  1
branch  1 taken 42
branch  2 taken 16 (fallthrough)
       42:   39:        image->comps[i].data = (int32_t*)malloc(width * height * sizeof(int32_t));
        -:   40:        // Initialize with 0
       42:   41:        memset(image->comps[i].data, 0, width * height * sizeof(int32_t));
       42:   41-block  0
unconditional  0 taken 42
        -:   42:    }
        -:   43:
       16:   44:    if (with_alpha && numcomps > 3) {
       16:   44-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 14
        2:   44-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2:   45:        image->comps[3].alpha = 1;
        2:   45-block  0
unconditional  0 taken 2
        -:   46:    }
        -:   47:
       16:   48:    return image;
       16:   48-block  0
unconditional  0 taken 16
        -:   49:}
        -:   50:
function test_argb8888 called 2 returned 100% blocks executed 54%
        2:   51:void test_argb8888() {
        2:   52:    printf("Testing ARGB8888...\n");
        2:   52-block  0
call    0 returned 2
        2:   53:    uint32_t width = 2;
        2:   54:    uint32_t height = 2;
        2:   55:    opj_image_t* image = create_mock_image(width, height, 4, 1);
call    0 returned 2
        -:   56:
        -:   57:    // Set specific pixels
        -:   58:    // Pixel 0 (Top-Left): Red (255, 0, 0, 128)
        2:   59:    image->comps[0].data[0] = 255;
        2:   60:    image->comps[1].data[0] = 0;
        2:   61:    image->comps[2].data[0] = 0;
        2:   62:    image->comps[3].data[0] = 128;
        -:   63:
        -:   64:    // Pixel 1 (Top-Right): Green (0, 255, 0, 255)
        2:   65:    image->comps[0].data[1] = 0;
        2:   66:    image->comps[1].data[1] = 255;
        2:   67:    image->comps[2].data[1] = 0;
        2:   68:    image->comps[3].data[1] = 255;
        -:   69:
        -:   70:    // Pixel 2 (Bottom-Left): Blue (0, 0, 255, 255)
        2:   71:    image->comps[0].data[2] = 0;
        2:   72:    image->comps[1].data[2] = 0;
        2:   73:    image->comps[2].data[2] = 255;
        2:   74:    image->comps[3].data[2] = 255;
        -:   75:
        -:   76:    // Pixel 3 (Bottom-Right): White (255, 255, 255, 255)
        2:   77:    image->comps[0].data[3] = 255;
        2:   78:    image->comps[1].data[3] = 255;
        2:   79:    image->comps[2].data[3] = 255;
        2:   80:    image->comps[3].data[3] = 255;
        -:   81:
        2:   82:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:   83:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:   83-block  0
call    2 never executed
        -:   84:
        -:   85:    // Check header
        -:   86:    // Offset 0: 'BM'
       2*:   87:    assert(bmp[0] == 0x42);
        2:   87-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:   87-block  1
call    2 never executed
       2*:   88:    assert(bmp[1] == 0x4D);
        2:   88-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:   88-block  1
call    2 never executed
        -:   89:
        -:   90:    // File size at offset 2
        2:   91:    uint32_t fileSize = *(uint32_t*)(bmp + 2);
        -:   92:    // Header 14 + DIB 40 = 54
        -:   93:    // Pixels: 2*2 * 4 = 16 bytes
        -:   94:    // Total 70 bytes
        2:   95:    if (fileSize != 54 + 16) {
        2:   95-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:   96:        printf("Expected file size 70, got %u\n", fileSize);
    %%%%%:   96-block  0
call    0 never executed
    #####:   97:        assert(fileSize == 54 + 16);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:   97-block  0
call    2 never executed
        -:   98:    }
        -:   99:
        -:  100:    // Pixel data at offset 54
        2:  101:    uint8_t* pixels = bmp + 54;
        -:  102:
        -:  103:    // Code uses BGRA order for ARGB8888
        -:  104:
        -:  105:    // Pixel 0: B=0, G=0, R=255, A=128
       2*:  106:    assert(pixels[0] == 0);   // B
        2:  106-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  106-block  1
call    2 never executed
       2*:  107:    assert(pixels[1] == 0);   // G
        2:  107-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  107-block  1
call    2 never executed
       2*:  108:    assert(pixels[2] == 255); // R
        2:  108-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  108-block  1
call    2 never executed
       2*:  109:    assert(pixels[3] == 128); // A
        2:  109-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  109-block  1
call    2 never executed
        -:  110:
        -:  111:    // Pixel 1: B=0, G=255, R=0, A=255
       2*:  112:    assert(pixels[4] == 0);
        2:  112-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  112-block  1
call    2 never executed
       2*:  113:    assert(pixels[5] == 255);
        2:  113-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  113-block  1
call    2 never executed
       2*:  114:    assert(pixels[6] == 0);
        2:  114-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  114-block  1
call    2 never executed
       2*:  115:    assert(pixels[7] == 255);
        2:  115-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  115-block  1
call    2 never executed
        -:  116:
        -:  117:    // Pixel 2: B=255, G=0, R=0, A=255
       2*:  118:    assert(pixels[8] == 255);
        2:  118-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  118-block  1
call    2 never executed
       2*:  119:    assert(pixels[9] == 0);
        2:  119-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  119-block  1
call    2 never executed
       2*:  120:    assert(pixels[10] == 0);
        2:  120-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  120-block  1
call    2 never executed
       2*:  121:    assert(pixels[11] == 255);
        2:  121-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  121-block  1
call    2 never executed
        -:  122:
        -:  123:    // Pixel 3: B=255, G=255, R=255, A=255
       2*:  124:    assert(pixels[12] == 255);
        2:  124-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  124-block  1
call    2 never executed
       2*:  125:    assert(pixels[13] == 255);
        2:  125-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  125-block  1
call    2 never executed
       2*:  126:    assert(pixels[14] == 255);
        2:  126-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  126-block  1
call    2 never executed
       2*:  127:    assert(pixels[15] == 255);
        2:  127-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  127-block  1
call    2 never executed
        -:  128:
        2:  129:    free(bmp);
        2:  130:    opj_image_destroy(image); // Uses our stub
        2:  130-block  0
call    0 returned 2
        2:  131:    printf("ARGB8888 Passed.\n");
call    0 returned 2
        2:  132:}
        -:  133:
function test_rgb565 called 2 returned 100% blocks executed 43%
        2:  134:void test_rgb565() {
        2:  135:    printf("Testing RGB565...\n");
        2:  135-block  0
call    0 returned 2
        2:  136:    uint32_t width = 2;
        2:  137:    uint32_t height = 2;
        2:  138:    opj_image_t* image = create_mock_image(width, height, 3, 0);
call    0 returned 2
        -:  139:
        -:  140:    // Pixel 0: Red (255, 0, 0)
        2:  141:    image->comps[0].data[0] = 255;
        2:  142:    image->comps[1].data[0] = 0;
        2:  143:    image->comps[2].data[0] = 0;
        -:  144:
        -:  145:    // Pixel 1: Green (0, 255, 0)
        2:  146:    image->comps[0].data[1] = 0;
        2:  147:    image->comps[1].data[1] = 255;
        2:  148:    image->comps[2].data[1] = 0;
        -:  149:
        -:  150:    // Pixel 2: Blue (0, 0, 255)
        2:  151:    image->comps[0].data[2] = 0;
        2:  152:    image->comps[1].data[2] = 0;
        2:  153:    image->comps[2].data[2] = 255;
        -:  154:
        -:  155:    // Pixel 3: White (255, 255, 255)
        2:  156:    image->comps[0].data[3] = 255;
        2:  157:    image->comps[1].data[3] = 255;
        2:  158:    image->comps[2].data[3] = 255;
        -:  159:
        2:  160:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_RGB565);
call    0 returned 2
       2*:  161:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  161-block  0
call    2 never executed
        -:  162:
        -:  163:    // Header size: 14 + 40 + 12 = 66
        -:  164:    // Pixels: 2 * 2bytes = 4 bytes per row. 2 rows. 8 bytes.
        -:  165:    // Total 74 bytes.
        2:  166:    uint32_t fileSize = *(uint32_t*)(bmp + 2);
        2:  167:    if (fileSize != 66 + 8) {
        2:  167-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  168:        printf("Expected file size 74, got %u\n", fileSize);
    %%%%%:  168-block  0
call    0 never executed
    #####:  169:        assert(fileSize == 66 + 8);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  169-block  0
call    2 never executed
        -:  170:    }
        -:  171:
        2:  172:    uint8_t* pixels = bmp + 66;
        -:  173:
        -:  174:    // RGB565: R(5) G(6) B(5)
        -:  175:    // Red: 11111 000000 00000 -> 0xF800
        -:  176:    // Green: 00000 111111 00000 -> 0x07E0
        -:  177:    // Blue: 00000 000000 11111 -> 0x001F
        -:  178:    // White: 11111 111111 11111 -> 0xFFFF
        -:  179:
        2:  180:    uint16_t* p16 = (uint16_t*)pixels;
        -:  181:
        2:  182:    if (p16[0] != 0xF800) {
        2:  182-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  183:        printf("Expected Red 0xF800, got 0x%04X\n", p16[0]);
    %%%%%:  183-block  0
call    0 never executed
    #####:  184:        assert(p16[0] == 0xF800);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  184-block  0
call    2 never executed
        -:  185:    }
        2:  186:    if (p16[1] != 0x07E0) {
        2:  186-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  187:        printf("Expected Green 0x07E0, got 0x%04X\n", p16[1]);
    %%%%%:  187-block  0
call    0 never executed
    #####:  188:        assert(p16[1] == 0x07E0);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  188-block  0
call    2 never executed
        -:  189:    }
        2:  190:    if (p16[2] != 0x001F) {
        2:  190-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  191:        printf("Expected Blue 0x001F, got 0x%04X\n", p16[2]);
    %%%%%:  191-block  0
call    0 never executed
    #####:  192:        assert(p16[2] == 0x001F);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  192-block  0
call    2 never executed
        -:  193:    }
        2:  194:    if (p16[3] != 0xFFFF) {
        2:  194-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  195:        printf("Expected White 0xFFFF, got 0x%04X\n", p16[3]);
    %%%%%:  195-block  0
call    0 never executed
    #####:  196:        assert(p16[3] == 0xFFFF);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  196-block  0
call    2 never executed
        -:  197:    }
        -:  198:
        2:  199:    free(bmp);
        2:  200:    opj_image_destroy(image);
        2:  200-block  0
call    0 returned 2
        2:  201:    printf("RGB565 Passed.\n");
call    0 returned 2
        2:  202:}
        -:  203:
function test_grayscale called 2 returned 100% blocks executed 61%
        2:  204:void test_grayscale() {
        2:  205:    printf("Testing Grayscale (1ch)...\n");
        2:  205-block  0
call    0 returned 2
        2:  206:    uint32_t width = 2;
        2:  207:    uint32_t height = 1;
        2:  208:    opj_image_t* image = create_mock_image(width, height, 1, 0);
call    0 returned 2
        -:  209:
        -:  210:    // Pixel 0: 0
        2:  211:    image->comps[0].data[0] = 0;
        -:  212:    // Pixel 1: 255
        2:  213:    image->comps[0].data[1] = 255;
        -:  214:
        -:  215:    // 1. Test ARGB8888 Expansion (Gray -> R=G=B, A=255)
        2:  216:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:  217:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  217-block  0
call    2 never executed
        2:  218:    uint8_t* pixels = bmp + 54;
        -:  219:
        -:  220:    // Pixel 0: B=0, G=0, R=0, A=255
       2*:  221:    assert(pixels[0] == 0);
        2:  221-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  221-block  1
call    2 never executed
       2*:  222:    assert(pixels[1] == 0);
        2:  222-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  222-block  1
call    2 never executed
       2*:  223:    assert(pixels[2] == 0);
        2:  223-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  223-block  1
call    2 never executed
       2*:  224:    assert(pixels[3] == 255);
        2:  224-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  224-block  1
call    2 never executed
        -:  225:
        -:  226:    // Pixel 1: B=255, G=255, R=255, A=255
       2*:  227:    assert(pixels[4] == 255);
        2:  227-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  227-block  1
call    2 never executed
       2*:  228:    assert(pixels[5] == 255);
        2:  228-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  228-block  1
call    2 never executed
       2*:  229:    assert(pixels[6] == 255);
        2:  229-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  229-block  1
call    2 never executed
       2*:  230:    assert(pixels[7] == 255);
        2:  230-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  230-block  1
call    2 never executed
        -:  231:
        2:  232:    free(bmp);
        -:  233:
        -:  234:    // 2. Test RGB565 Expansion (Gray -> R=G=B)
        2:  235:    bmp = convert_image_to_bmp(image, COLOR_FORMAT_RGB565);
        2:  235-block  0
call    0 returned 2
       2*:  236:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  236-block  0
call    2 never executed
        2:  237:    uint16_t* p16 = (uint16_t*)(bmp + 66);
        -:  238:
        -:  239:    // Pixel 0: Black (0x0000)
       2*:  240:    assert(p16[0] == 0x0000);
        2:  240-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  240-block  1
call    2 never executed
        -:  241:
        -:  242:    // Pixel 1: White (0xFFFF)
       2*:  243:    assert(p16[1] == 0xFFFF);
        2:  243-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  243-block  1
call    2 never executed
        -:  244:
        2:  245:    free(bmp);
        2:  246:    opj_image_destroy(image);
        2:  246-block  0
call    0 returned 2
        2:  247:    printf("Grayscale Passed.\n");
call    0 returned 2
        2:  248:}
        -:  249:
function test_grayscale_alpha called 2 returned 100% blocks executed 69%
        2:  250:void test_grayscale_alpha() {
        2:  251:    printf("Testing Grayscale + Alpha (2ch)...\n");
        2:  251-block  0
call    0 returned 2
        2:  252:    uint32_t width = 1;
        2:  253:    uint32_t height = 1;
        2:  254:    opj_image_t* image = create_mock_image(width, height, 2, 0);
call    0 returned 2
        -:  255:
        -:  256:    // Gray: 100
        2:  257:    image->comps[0].data[0] = 100;
        -:  258:    // Alpha: 200 (explicitly marked as alpha by our logic check if we set the flag,
        -:  259:    // OR just by position if we assume 2nd channel is alpha?
        -:  260:    // My code says: if (image->comps[1].alpha != 0) { a_data = image->comps[1].data; }
        -:  261:    // So I must set the alpha flag in the mock for it to be picked up as Alpha.
        2:  262:    image->comps[1].data[0] = 200;
        2:  263:    image->comps[1].alpha = 1;
        -:  264:
        2:  265:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:  266:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  266-block  0
call    2 never executed
        2:  267:    uint8_t* pixels = bmp + 54;
        -:  268:
        -:  269:    // B=100, G=100, R=100, A=200
       2*:  270:    assert(pixels[0] == 100);
        2:  270-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  270-block  1
call    2 never executed
       2*:  271:    assert(pixels[1] == 100);
        2:  271-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  271-block  1
call    2 never executed
       2*:  272:    assert(pixels[2] == 100);
        2:  272-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  272-block  1
call    2 never executed
       2*:  273:    assert(pixels[3] == 200);
        2:  273-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  273-block  1
call    2 never executed
        -:  274:
        2:  275:    free(bmp);
        2:  276:    opj_image_destroy(image);
        2:  276-block  0
call    0 returned 2
        2:  277:    printf("Grayscale + Alpha Passed.\n");
call    0 returned 2
        2:  278:}
        -:  279:
function test_multichannel called 2 returned 100% blocks executed 69%
        2:  280:void test_multichannel() {
        2:  281:    printf("Testing Multi-channel (5ch)...\n");
        2:  281-block  0
call    0 returned 2
        2:  282:    uint32_t width = 1;
        2:  283:    uint32_t height = 1;
        2:  284:    opj_image_t* image = create_mock_image(width, height, 5, 0);
call    0 returned 2
        -:  285:
        -:  286:    // Set pixel values
        -:  287:    // Comp 0 (R): 255
        2:  288:    image->comps[0].data[0] = 255;
        -:  289:    // Comp 1 (G): 0
        2:  290:    image->comps[1].data[0] = 0;
        -:  291:    // Comp 2 (B): 0
        2:  292:    image->comps[2].data[0] = 0;
        -:  293:    // Comp 3 (A): 128 (treated as alpha if flag set, or index 3 if not)
        -:  294:    // In create_mock_image, we didn't set alpha flag for index 3 unless called with with_alpha=1
        -:  295:    // But get_alpha_component returns comps[3].data if no alpha flag is found and numcomps > 3
        2:  296:    image->comps[3].data[0] = 128;
        -:  297:    // Comp 4 (Ignored): 100
        2:  298:    image->comps[4].data[0] = 100;
        -:  299:
        2:  300:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:  301:    assert(bmp != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  301-block  0
call    2 never executed
        2:  302:    uint8_t* pixels = bmp + 54;
        -:  303:
        -:  304:    // Check BGRA
        -:  305:    // B=0 (from comp 2)
       2*:  306:    assert(pixels[0] == 0);
        2:  306-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  306-block  1
call    2 never executed
        -:  307:    // G=0 (from comp 1)
       2*:  308:    assert(pixels[1] == 0);
        2:  308-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  308-block  1
call    2 never executed
        -:  309:    // R=255 (from comp 0)
       2*:  310:    assert(pixels[2] == 255);
        2:  310-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  310-block  1
call    2 never executed
        -:  311:    // A=128 (from comp 3)
       2*:  312:    assert(pixels[3] == 128);
        2:  312-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  312-block  1
call    2 never executed
        -:  313:
        2:  314:    free(bmp);
        2:  315:    opj_image_destroy(image);
        2:  315-block  0
call    0 returned 2
        2:  316:    printf("Multi-channel Passed.\n");
call    0 returned 2
        2:  317:}
        -:  318:
function test_input_validation called 2 returned 100% blocks executed 64%
        2:  319:void test_input_validation() {
        2:  320:    printf("Testing Input Validation...\n");
        2:  320-block  0
call    0 returned 2
        -:  321:
        2:  322:    uint8_t dummy_data[100] = {0};
        -:  323:    uint8_t* result;
        -:  324:
        -:  325:    // Case 1: Input size too small (< MIN_INPUT_SIZE)
        2:  326:    result = decodeToBmp(dummy_data, 11, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  327:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  327-block  0
call    2 never executed
       2*:  328:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  328-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  328-block  1
call    2 never executed
        -:  329:
        -:  330:    // Case 2: ARGB8888 size check (data_len > max_heap / 4)
        -:  331:    // max_heap = 100 -> max_input = 25
        -:  332:    // input = 26 -> Error
        2:  333:    result = decodeToBmp(dummy_data, 26, 0, 100, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
        2:  333-block  0
call    0 returned 2
       2*:  334:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  334-block  0
call    2 never executed
       2*:  335:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  335-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  335-block  1
call    2 never executed
        -:  336:
        -:  337:    // Case 3: ARGB8888 size check success boundary
        -:  338:    // max_heap = 100 -> max_input = 25
        -:  339:    // input = 25 -> OK (proceeds to decode, fails there)
        2:  340:    result = decodeToBmp(dummy_data, 25, 0, 100, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
        2:  340-block  0
call    0 returned 2
       2*:  341:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  341-block  0
call    2 never executed
        -:  342:    // Since stubs opj_read_header returns false, we expect ERR_HEADER
        -:  343:    // But verify it PASSED the size check (NOT ERR_INPUT_DATA_SIZE)
       2*:  344:    assert(last_error == ERR_HEADER);
        2:  344-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  344-block  1
call    2 never executed
        -:  345:
        -:  346:    // Case 4: RGB565 size check (data_len > max_heap / 2)
        -:  347:    // max_heap = 100 -> max_input = 50
        -:  348:    // input = 51 -> Error
        2:  349:    result = decodeToBmp(dummy_data, 51, 0, 100, COLOR_FORMAT_RGB565, 0, 0, 0, 0);
        2:  349-block  0
call    0 returned 2
       2*:  350:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  350-block  0
call    2 never executed
       2*:  351:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  351-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  351-block  1
call    2 never executed
        -:  352:
        -:  353:    // Case 5: RGB565 size check success boundary
        -:  354:    // max_heap = 100 -> max_input = 50
        -:  355:    // input = 50 -> OK (proceeds to decode)
        2:  356:    result = decodeToBmp(dummy_data, 50, 0, 100, COLOR_FORMAT_RGB565, 0, 0, 0, 0);
        2:  356-block  0
call    0 returned 2
       2*:  357:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  357-block  0
call    2 never executed
       2*:  358:    assert(last_error == ERR_HEADER);
        2:  358-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  358-block  1
call    2 never executed
        -:  359:
        2:  360:    printf("Input Validation Passed.\n");
        2:  360-block  0
call    0 returned 2
        2:  361:}
        -:  362:
        -:  363:extern int stub_should_header_succeed;
        -:  364:extern uint32_t stub_width;
        -:  365:extern uint32_t stub_height;
        -:  366:extern int stub_should_decompress_create_succeed;
        -:  367:extern int stub_should_setup_succeed;
        -:  368:extern int stub_should_decode_succeed;
        -:  369:extern int stub_should_set_decode_area_succeed;
        -:  370:
function test_getLastError called 2 returned 100% blocks executed 83%
        2:  371:void test_getLastError() {
        2:  372:    printf("Testing getLastError...\n");
        2:  372-block  0
call    0 returned 2
        2:  373:    last_error = 123;
       2*:  374:    assert(getLastError() == 123);
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:  374-block  0
call    3 never executed
        2:  375:    last_error = ERR_NONE;
        2:  376:    printf("getLastError Passed.\n");
        2:  376-block  0
call    0 returned 2
        2:  377:}
        -:  378:
function test_opj_read_from_buffer called 2 returned 100% blocks executed 65%
        2:  379:void test_opj_read_from_buffer() {
        2:  380:    printf("Testing opj_read_from_buffer...\n");
        2:  380-block  0
call    0 returned 2
        2:  381:    uint8_t buffer[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        2:  382:    opj_buffer_info_t info = {buffer, 10, 0};
        -:  383:    uint8_t dest[10];
        -:  384:
        -:  385:    // Normal Read
       2*:  386:    assert(opj_read_from_buffer(dest, 5, &info) == 5);
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:  386-block  0
call    3 never executed
       2*:  387:    assert(info.offset == 5);
        2:  387-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  387-block  1
call    2 never executed
       2*:  388:    assert(memcmp(dest, buffer, 5) == 0);
        2:  388-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  388-block  1
call    2 never executed
        -:  389:
        -:  390:    // Read remaining
       2*:  391:    assert(opj_read_from_buffer(dest, 10, &info) == 5); // Only 5 left
        2:  391-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:  391-block  1
call    3 never executed
       2*:  392:    assert(info.offset == 10);
        2:  392-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  392-block  1
call    2 never executed
       2*:  393:    assert(memcmp(dest, buffer + 5, 5) == 0);
        2:  393-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  393-block  1
call    2 never executed
        -:  394:
        -:  395:    // Read past end
       2*:  396:    assert(opj_read_from_buffer(dest, 1, &info) == (OPJ_SIZE_T)-1);
        2:  396-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:  396-block  1
call    3 never executed
        -:  397:
        2:  398:    printf("opj_read_from_buffer Passed.\n");
        2:  398-block  0
call    0 returned 2
        2:  399:}
        -:  400:
function test_set_decode_area_failure called 2 returned 100% blocks executed 75%
        2:  401:void test_set_decode_area_failure() {
        2:  402:    printf("Testing opj_set_decode_area Failure...\n");
        2:  402-block  0
call    0 returned 2
        2:  403:    uint8_t dummy_data[20] = {0};
        2:  404:    stub_should_header_succeed = 1;
        2:  405:    stub_width = 100;
        2:  406:    stub_height = 100;
        -:  407:
        2:  408:    stub_should_set_decode_area_succeed = 0;
        -:  409:
        -:  410:    // Trigger partial decode
        2:  411:    uint8_t* result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 10, 10, 20, 20);
call    0 returned 2
       2*:  412:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  412-block  0
call    2 never executed
       2*:  413:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  413-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  413-block  1
call    2 never executed
        -:  414:
        2:  415:    stub_should_set_decode_area_succeed = 1;
        2:  416:    stub_should_header_succeed = 0;
        2:  417:    printf("opj_set_decode_area Failure Passed.\n");
        2:  417-block  0
call    0 returned 2
        2:  418:}
        -:  419:
function test_pixel_limit_decode_failure called 2 returned 100% blocks executed 75%
        2:  420:void test_pixel_limit_decode_failure() {
        2:  421:    printf("Testing Pixel Limit Decode Failure...\n");
        2:  421-block  0
call    0 returned 2
        2:  422:    uint8_t dummy_data[20] = {0};
        2:  423:    stub_should_header_succeed = 1;
        2:  424:    stub_width = 10;
        2:  425:    stub_height = 10;
        -:  426:    // Pixels = 100. Limit = 200. Check passes.
        -:  427:
        2:  428:    stub_should_decode_succeed = 0; // Fail decode
        -:  429:
        2:  430:    uint8_t* result = decodeToBmp(dummy_data, 20, 200, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  431:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  431-block  0
call    2 never executed
       2*:  432:    assert(last_error == ERR_DECODE);
        2:  432-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  432-block  1
call    2 never executed
        -:  433:
        2:  434:    stub_should_header_succeed = 0;
        2:  435:    printf("Pixel Limit Decode Failure Passed.\n");
        2:  435-block  0
call    0 returned 2
        2:  436:}
        -:  437:
function test_pixel_limit_partial_decode_failure called 2 returned 100% blocks executed 75%
        2:  438:void test_pixel_limit_partial_decode_failure() {
        2:  439:    printf("Testing Pixel Limit Partial Decode Failure...\n");
        2:  439-block  0
call    0 returned 2
        2:  440:    uint8_t dummy_data[20] = {0};
        2:  441:    stub_should_header_succeed = 1;
        2:  442:    stub_width = 20;
        2:  443:    stub_height = 20;
        -:  444:    // Original Pixels = 400.
        -:  445:    // Limit = 100.
        -:  446:    // Original exceeds limit (400 > 100).
        -:  447:
        -:  448:    // Partial: 5x5 = 25 pixels. Fits in 100.
        -:  449:
        2:  450:    stub_should_decode_succeed = 0; // Fail decode
        -:  451:
        -:  452:    // x0=0, y0=0, x1=5, y1=5
        2:  453:    uint8_t* result = decodeToBmp(dummy_data, 20, 100, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 5, 5);
call    0 returned 2
       2*:  454:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  454-block  0
call    2 never executed
       2*:  455:    assert(last_error == ERR_DECODE);
        2:  455-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  455-block  1
call    2 never executed
        -:  456:
        2:  457:    stub_should_header_succeed = 0;
        2:  458:    printf("Pixel Limit Partial Decode Failure Passed.\n");
        2:  458-block  0
call    0 returned 2
        2:  459:}
        -:  460:
function test_conversion_failures called 2 returned 100% blocks executed 75%
        2:  461:void test_conversion_failures() {
        2:  462:    printf("Testing Conversion Failures...\n");
        2:  462-block  0
call    0 returned 2
        -:  463:
        -:  464:    // 1. 0 Components
        2:  465:    opj_image_t* image = create_mock_image(10, 10, 0, 0); // 0 comps
call    0 returned 2
        2:  466:    uint8_t* bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:  467:    assert(bmp == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  467-block  0
call    2 never executed
       2*:  468:    assert(last_error == ERR_DECODE);
        2:  468-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  468-block  1
call    2 never executed
        2:  469:    opj_image_destroy(image);
        2:  469-block  0
call    0 returned 2
        -:  470:
        -:  471:    // 2. Malloc Failure (ARGB8888)
        2:  472:    stub_should_malloc_succeed = 0;
        2:  473:    image = create_mock_image(10, 10, 3, 0);
call    0 returned 2
        2:  474:    bmp = convert_image_to_bmp(image, COLOR_FORMAT_ARGB8888);
call    0 returned 2
       2*:  475:    assert(bmp == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  475-block  0
call    2 never executed
       2*:  476:    assert(last_error == ERR_DECODE);
        2:  476-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  476-block  1
call    2 never executed
        2:  477:    opj_image_destroy(image);
        2:  477-block  0
call    0 returned 2
        2:  478:    stub_should_malloc_succeed = 1;
        -:  479:
        -:  480:    // 3. Malloc Failure (RGB565)
        2:  481:    stub_should_malloc_succeed = 0;
        2:  482:    image = create_mock_image(10, 10, 3, 0);
call    0 returned 2
        2:  483:    bmp = convert_image_to_bmp(image, COLOR_FORMAT_RGB565);
call    0 returned 2
       2*:  484:    assert(bmp == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  484-block  0
call    2 never executed
       2*:  485:    assert(last_error == ERR_DECODE);
        2:  485-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  485-block  1
call    2 never executed
        2:  486:    opj_image_destroy(image);
        2:  486-block  0
call    0 returned 2
        2:  487:    stub_should_malloc_succeed = 1;
        -:  488:
        2:  489:    printf("Conversion Failures Passed.\n");
call    0 returned 2
        2:  490:}
        -:  491:
function test_ratio_decode_success called 2 returned 100% blocks executed 78%
        2:  492:void test_ratio_decode_success() {
        2:  493:    printf("Testing Ratio Decode Success...\n");
        2:  493-block  0
call    0 returned 2
        2:  494:    uint8_t dummy_data[20] = {0};
        2:  495:    stub_should_header_succeed = 1;
        2:  496:    stub_should_decode_succeed = 1;
        2:  497:    stub_width = 100;
        2:  498:    stub_height = 100;
        -:  499:
        -:  500:    // Full decode via ratio 0,0,1,1
        2:  501:    uint8_t* result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.0, 0.0, 1.0, 1.0);
call    0 returned 2
       2*:  502:    assert(result != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  502-block  0
call    2 never executed
        2:  503:    free(result);
        -:  504:
        -:  505:    // Partial decode with clamping (e.g. 1.5)
        2:  506:    result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.0, 0.0, 1.5, 1.5);
        2:  506-block  0
call    0 returned 2
        -:  507:    // Should pass (clamped to 1.0)
       2*:  508:    assert(result != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  508-block  0
call    2 never executed
        2:  509:    free(result);
        -:  510:
        2:  511:    stub_should_header_succeed = 0;
        2:  512:    stub_should_decode_succeed = 0;
        2:  513:    printf("Ratio Decode Success Passed.\n");
        2:  513-block  0
call    0 returned 2
        2:  514:}
        -:  515:
function test_getSize_decoder_failure called 2 returned 100% blocks executed 69%
        2:  516:void test_getSize_decoder_failure() {
        2:  517:    printf("Testing getSize Decoder Failure...\n");
        2:  517-block  0
call    0 returned 2
        2:  518:    uint8_t dummy_data[20] = {0};
        -:  519:
        -:  520:    // 1. Decoder Setup Failure
        2:  521:    stub_should_decompress_create_succeed = 0;
        2:  522:    uint32_t* result = getSize(dummy_data, 20);
call    0 returned 2
       2*:  523:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  523-block  0
call    2 never executed
       2*:  524:    assert(last_error == ERR_DECODER_SETUP);
        2:  524-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  524-block  1
call    2 never executed
        2:  525:    stub_should_decompress_create_succeed = 1;
        -:  526:
        -:  527:    // 2. Malloc Failure (Result Array)
        2:  528:    stub_should_header_succeed = 1;
        2:  529:    stub_width = 100;
        2:  530:    stub_height = 100;
        2:  531:    stub_should_malloc_succeed = 0;
        -:  532:
        2:  533:    result = getSize(dummy_data, 20);
        2:  533-block  0
call    0 returned 2
       2*:  534:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  534-block  0
call    2 never executed
       2*:  535:    assert(last_error == ERR_DECODE);
        2:  535-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  535-block  1
call    2 never executed
        -:  536:
        2:  537:    stub_should_malloc_succeed = 1;
        2:  538:    stub_should_header_succeed = 0;
        -:  539:
        2:  540:    printf("getSize Decoder Failure Passed.\n");
        2:  540-block  0
call    0 returned 2
        2:  541:}
        -:  542:
function test_jp2_signature called 2 returned 100% blocks executed 75%
        2:  543:void test_jp2_signature() {
        2:  544:    printf("Testing JP2 Signature...\n");
        2:  544-block  0
call    0 returned 2
        -:  545:    // JP2 Signature: 00 00 00 0C ...
        2:  546:    uint8_t dummy_data[20] = {0x00, 0x00, 0x00, 0x0C, 0x00};
        -:  547:
        -:  548:    // We expect it to reach decode_internal and fail at opj_read_header (since we didn't set stub_should_header_succeed)
        -:  549:    // But we want to ensure it calls opj_create_decompress(OPJ_CODEC_JP2)
        -:  550:    // We can't verify the argument to opj_create_decompress easily without mocking it with arg check.
        -:  551:    // However, we know get_codec_format is called.
        -:  552:    // This test is mainly to execute the line in get_codec_format.
        -:  553:
        2:  554:    uint8_t* result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  555:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  555-block  0
call    2 never executed
       2*:  556:    assert(last_error == ERR_HEADER);
        2:  556-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  556-block  1
call    2 never executed
        2:  557:    printf("JP2 Signature Passed.\n");
        2:  557-block  0
call    0 returned 2
        2:  558:}
        -:  559:
function test_pixel_limit called 2 returned 100% blocks executed 75%
        2:  560:void test_pixel_limit() {
        2:  561:    printf("Testing Pixel Limit...\n");
        2:  561-block  0
call    0 returned 2
        2:  562:    uint8_t dummy_data[20] = {0};
        -:  563:
        -:  564:    // Setup success stubs for header
        2:  565:    stub_should_header_succeed = 1;
        2:  566:    stub_width = 20;
        2:  567:    stub_height = 20;
        -:  568:    // Pixels = 400.
        -:  569:
        -:  570:    // Limit = 100.
        2:  571:    uint8_t* result = decodeToBmp(dummy_data, 20, 100, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  572:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  572-block  0
call    2 never executed
       2*:  573:    assert(last_error == ERR_PIXEL_DATA_SIZE);
        2:  573-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  573-block  1
call    2 never executed
        -:  574:
        2:  575:    printf("Pixel Limit Passed.\n");
        2:  575-block  0
call    0 returned 2
        2:  576:    stub_should_header_succeed = 0;
        2:  577:}
        -:  578:
function test_full_decode_success called 2 returned 100% blocks executed 69%
        2:  579:void test_full_decode_success() {
        2:  580:    printf("Testing Full Decode Success...\n");
        2:  580-block  0
call    0 returned 2
        2:  581:    uint8_t dummy_data[20] = {0};
        -:  582:
        2:  583:    stub_should_header_succeed = 1;
        2:  584:    stub_should_decode_succeed = 1;
        2:  585:    stub_width = 10;
        2:  586:    stub_height = 10;
        -:  587:
        -:  588:    // ARGB8888
        2:  589:    uint8_t* result = decodeToBmp(dummy_data, 20, 0, 10000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  590:    assert(result != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  590-block  0
call    2 never executed
        -:  591:
        -:  592:    // Check BMP header briefly
       2*:  593:    assert(result[0] == 0x42);
        2:  593-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  593-block  1
call    2 never executed
       2*:  594:    assert(result[1] == 0x4D);
        2:  594-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  594-block  1
call    2 never executed
        -:  595:
        2:  596:    free(result);
        -:  597:
        -:  598:    // RGB565
        2:  599:    result = decodeToBmp(dummy_data, 20, 0, 10000, COLOR_FORMAT_RGB565, 0, 0, 0, 0);
        2:  599-block  0
call    0 returned 2
       2*:  600:    assert(result != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  600-block  0
call    2 never executed
        2:  601:    free(result);
        -:  602:
        2:  603:    printf("Full Decode Success Passed.\n");
        2:  603-block  0
call    0 returned 2
        2:  604:    stub_should_header_succeed = 0;
        2:  605:    stub_should_decode_succeed = 0;
        2:  606:}
        -:  607:
function test_getSize called 2 returned 100% blocks executed 67%
        2:  608:void test_getSize() {
        2:  609:    printf("Testing getSize...\n");
        2:  609-block  0
call    0 returned 2
        2:  610:    uint8_t dummy_data[20] = {0}; // > MIN_INPUT_SIZE (12)
        -:  611:
        -:  612:    // Case 1: Header failure
        2:  613:    stub_should_header_succeed = 0;
        2:  614:    uint32_t* result = getSize(dummy_data, 20);
call    0 returned 2
       2*:  615:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  615-block  0
call    2 never executed
       2*:  616:    assert(last_error == ERR_HEADER);
        2:  616-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  616-block  1
call    2 never executed
        -:  617:
        -:  618:    // Case 2: Success
        2:  619:    stub_should_header_succeed = 1;
        2:  620:    stub_width = 1920;
        2:  621:    stub_height = 1080;
        -:  622:
        2:  623:    result = getSize(dummy_data, 20);
        2:  623-block  0
call    0 returned 2
       2*:  624:    assert(result != NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  624-block  0
call    2 never executed
       2*:  625:    assert(result[0] == 1920);
        2:  625-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  625-block  1
call    2 never executed
       2*:  626:    assert(result[1] == 1080);
        2:  626-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  626-block  1
call    2 never executed
        -:  627:
        2:  628:    free(result);
        2:  629:    printf("getSize Passed.\n");
        2:  629-block  0
call    0 returned 2
        -:  630:
        -:  631:    // Reset stubs
        2:  632:    stub_should_header_succeed = 0;
        2:  633:}
        -:  634:
function test_decode_failures called 2 returned 100% blocks executed 70%
        2:  635:void test_decode_failures() {
        2:  636:    printf("Testing Decode Failures...\n");
        2:  636-block  0
call    0 returned 2
        2:  637:    uint8_t dummy_data[100] = {0};
        -:  638:
        -:  639:    // 1. Null Data
        2:  640:    printf("Debug: 1. Null Data\n");
call    0 returned 2
        2:  641:    uint8_t* result = decodeToBmp(NULL, 100, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  642:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  642-block  0
call    2 never executed
       2*:  643:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  643-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  643-block  1
call    2 never executed
        -:  644:
        -:  645:    // 2. Zero Length
        2:  646:    printf("Debug: 2. Zero Length\n");
        2:  646-block  0
call    0 returned 2
        2:  647:    result = decodeToBmp(dummy_data, 0, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  648:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  648-block  0
call    2 never executed
       2*:  649:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  649-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  649-block  1
call    2 never executed
        -:  650:
        -:  651:    // 3. Create Decoder Failure
        2:  652:    printf("Debug: 3. Create Decoder Failure\n");
        2:  652-block  0
call    0 returned 2
        2:  653:    stub_should_decompress_create_succeed = 0;
        2:  654:    result = decodeToBmp(dummy_data, 100, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  655:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  655-block  0
call    2 never executed
       2*:  656:    assert(last_error == ERR_DECODER_SETUP);
        2:  656-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  656-block  1
call    2 never executed
        2:  657:    stub_should_decompress_create_succeed = 1; // Reset
        -:  658:
        -:  659:    // 4. Setup Decoder Failure
        2:  660:    printf("Debug: 4. Setup Decoder Failure\n");
        2:  660-block  0
call    0 returned 2
        2:  661:    stub_should_setup_succeed = 0;
        2:  662:    result = decodeToBmp(dummy_data, 100, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  663:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  663-block  0
call    2 never executed
       2*:  664:    assert(last_error == ERR_DECODER_SETUP);
        2:  664-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  664-block  1
call    2 never executed
        2:  665:    stub_should_setup_succeed = 1; // Reset
        -:  666:
        2:  667:    printf("Decode Failures Passed.\n");
        2:  667-block  0
call    0 returned 2
        2:  668:}
        -:  669:
function test_bounds_check called 2 returned 100% blocks executed 64%
        2:  670:void test_bounds_check() {
        2:  671:    printf("Testing Bounds Check...\n");
        2:  671-block  0
call    0 returned 2
        2:  672:    uint8_t dummy_data[20] = {0};
        -:  673:
        -:  674:    // Setup success stubs
        2:  675:    stub_should_header_succeed = 1;
        2:  676:    stub_width = 100;
        2:  677:    stub_height = 100;
        -:  678:
        -:  679:    // 1. Valid Full Decode (explicit 0s)
        2:  680:    uint8_t* result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 0, 0);
call    0 returned 2
       2*:  681:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  681-block  0
call    2 never executed
        -:  682:    // decode stub returns FALSE, so ERR_DECODE is expected, NOT ERR_REGION_OUT_OF_BOUNDS
       2*:  683:    assert(last_error == ERR_DECODE);
        2:  683-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  683-block  1
call    2 never executed
        -:  684:
        -:  685:    // 2. Valid Partial Decode
        2:  686:    result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 10, 10, 20, 20);
        2:  686-block  0
call    0 returned 2
       2*:  687:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  687-block  0
call    2 never executed
       2*:  688:    assert(last_error == ERR_DECODE);
        2:  688-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  688-block  1
call    2 never executed
        -:  689:
        -:  690:    // 3. Invalid: x1 > width
        2:  691:    result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 101, 20);
        2:  691-block  0
call    0 returned 2
       2*:  692:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  692-block  0
call    2 never executed
       2*:  693:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  693-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  693-block  1
call    2 never executed
        -:  694:
        -:  695:    // 4. Invalid: y1 > height
        2:  696:    result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0, 0, 100, 101);
        2:  696-block  0
call    0 returned 2
       2*:  697:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  697-block  0
call    2 never executed
       2*:  698:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  698-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  698-block  1
call    2 never executed
        -:  699:
        -:  700:    // 5. Invalid: x0 < 0 (uint32, so large number check? No, passed as uint32, always >= 0)
        -:  701:    // Checking bounds relative to x1.
        -:  702:    // Invalid: x0 >= x1
        2:  703:    result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 20, 0, 20, 20);
        2:  703-block  0
call    0 returned 2
       2*:  704:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  704-block  0
call    2 never executed
       2*:  705:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  705-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  705-block  1
call    2 never executed
        -:  706:
        -:  707:    // 6. Invalid: x0 >= x1 (bigger)
        2:  708:    result = decodeToBmp(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 21, 0, 20, 20);
        2:  708-block  0
call    0 returned 2
       2*:  709:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  709-block  0
call    2 never executed
       2*:  710:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  710-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  710-block  1
call    2 never executed
        -:  711:
        2:  712:    printf("Bounds Check Passed.\n");
        2:  712-block  0
call    0 returned 2
        -:  713:
        2:  714:    stub_should_header_succeed = 0;
        2:  715:}
        -:  716:
function test_getsize_failures called 2 returned 100% blocks executed 69%
        2:  717:void test_getsize_failures() {
        2:  718:    printf("Testing getSize Failures...\n");
        2:  718-block  0
call    0 returned 2
        2:  719:    uint8_t dummy_data[100] = {0};
        -:  720:
        -:  721:    // 1. Null Data
        2:  722:    uint32_t* result = getSize(NULL, 100);
call    0 returned 2
       2*:  723:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  723-block  0
call    2 never executed
       2*:  724:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  724-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  724-block  1
call    2 never executed
        -:  725:
        -:  726:    // 2. Zero Length
        2:  727:    result = getSize(dummy_data, 0);
        2:  727-block  0
call    0 returned 2
       2*:  728:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  728-block  0
call    2 never executed
       2*:  729:    assert(last_error == ERR_INPUT_DATA_SIZE);
        2:  729-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  729-block  1
call    2 never executed
        -:  730:
        2:  731:    printf("getSize Failures Passed.\n");
        2:  731-block  0
call    0 returned 2
        2:  732:}
        -:  733:
function test_ratio_decode called 2 returned 100% blocks executed 65%
        2:  734:void test_ratio_decode() {
        2:  735:    printf("Testing Ratio Decode...\n");
        2:  735-block  0
call    0 returned 2
        2:  736:    uint8_t dummy_data[20] = {0};
        -:  737:
        -:  738:    // Setup success stubs
        2:  739:    stub_should_header_succeed = 1;
        2:  740:    stub_width = 100;
        2:  741:    stub_height = 200;
        -:  742:
        -:  743:    // Test 1: Ratio 0.0, 0.0, 0.5, 0.5 -> 0, 0, 50, 100
        -:  744:    // We expect decode_internal to call opj_set_decode_area(..., 0, 0, 50, 100)
        -:  745:    // But we can't verify that directly in this unit test structure unless we mock opj_set_decode_area and record args.
        -:  746:    // However, we can verify that it does NOT return OUT_OF_BOUNDS for valid ratio.
        -:  747:
        -:  748:    // 0.0, 0.0, 0.5, 0.5
        2:  749:    uint8_t* result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.0, 0.0, 0.5, 0.5);
call    0 returned 2
        -:  750:    // It should fail at opj_decode stage (ERR_DECODE), not REGION_OUT_OF_BOUNDS
       2*:  751:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  751-block  0
call    2 never executed
       2*:  752:    assert(last_error == ERR_DECODE);
        2:  752-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  752-block  1
call    2 never executed
        -:  753:
        -:  754:    // Test 2: Invalid Ratio (resulting in out of bounds?)
        -:  755:    // 0.0, 0.0, 1.1, 1.1 -> 0, 0, 100, 200 (clamped)
        -:  756:    // My implementation clamps to width/height.
        -:  757:    // So 1.1 becomes 1.0 (width).
        -:  758:    // So it should still be valid.
        2:  759:    result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.0, 0.0, 1.1, 1.1);
        2:  759-block  0
call    0 returned 2
       2*:  760:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  760-block  0
call    2 never executed
       2*:  761:    assert(last_error == ERR_DECODE);
        2:  761-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  761-block  1
call    2 never executed
        -:  762:
        -:  763:    // Test 3: "Empty" ratio? 0.5, 0.5, 0.5, 0.5 -> x0=50, x1=50 -> is_partial=0?
        -:  764:    // x0=50, y0=100, x1=50, y1=100.
        -:  765:    // is_partial check: (ux1 != 0 || uy1 != 0) -> true.
        -:  766:    // bounds check: ux0 >= ux1 -> 50 >= 50 -> fail.
        2:  767:    result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.5, 0.5, 0.5, 0.5);
        2:  767-block  0
call    0 returned 2
       2*:  768:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  768-block  0
call    2 never executed
       2*:  769:    assert(last_error == ERR_REGION_OUT_OF_BOUNDS);
        2:  769-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  769-block  1
call    2 never executed
        -:  770:
        -:  771:    // Test 4: Ratio Full Decode (0.0, 0.0, 1.0, 1.0) -> 0, 0, 100, 200
        -:  772:    // ux0=0, uy0=0, ux1=100, uy1=200.
        -:  773:    // is_partial = (100!=0 || 200!=0) -> true.
        -:  774:    // Bounds OK. opj_set_decode_area called.
        2:  775:    result = decodeToBmpWithRatio(dummy_data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, 0.0, 0.0, 1.0, 1.0);
        2:  775-block  0
call    0 returned 2
       2*:  776:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  776-block  0
call    2 never executed
       2*:  777:    assert(last_error == ERR_DECODE);
        2:  777-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    %%%%%:  777-block  1
call    2 never executed
        -:  778:
        2:  779:    printf("Ratio Decode Passed.\n");
        2:  779-block  0
call    0 returned 2
        2:  780:    stub_should_header_succeed = 0;
        2:  781:}
        -:  782:
function check_decode_boundary called 32 returned 100% blocks executed 50%
       32:  783:void check_decode_boundary(const char* test_name, uint8_t* data, uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, int expected_error) {
       32:  784:    uint8_t* result = decodeToBmp(data, 20, 0, 1000, COLOR_FORMAT_ARGB8888, x0, y0, x1, y1);
       32:  784-block  0
call    0 returned 32
      32*:  785:    assert(result == NULL);
branch  0 taken 0 (fallthrough)
branch  1 taken 32
    %%%%%:  785-block  0
call    2 never executed
       32:  786:    if (last_error != expected_error) {
       32:  786-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 32
    #####:  787:        printf("Test '%s' failed: expected error %d, got %d\n", test_name, expected_error, last_error);
    %%%%%:  787-block  0
call    0 never executed
    #####:  788:        assert(last_error == expected_error);
branch  0 never executed (fallthrough)
branch  1 never executed
    %%%%%:  788-block  0
call    2 never executed
        -:  789:    }
       32:  790:}
        -:  791:
function test_detailed_boundaries called 2 returned 100% blocks executed 100%
        2:  792:void test_detailed_boundaries() {
        2:  793:    printf("Testing Detailed Boundaries...\n");
        2:  793-block  0
call    0 returned 2
        2:  794:    uint8_t dummy_data[20] = {0};
        -:  795:
        -:  796:    // Setup success stubs for 100x100 image
        2:  797:    stub_should_header_succeed = 1;
        2:  798:    stub_width = 100;
        2:  799:    stub_height = 100;
        -:  800:
        -:  801:    // 1. Left-Up Limit: 0, 0, 10, 10 (Valid)
        2:  802:    check_decode_boundary("1. Left-Up Limit", dummy_data, 0, 0, 10, 10, ERR_DECODE);
call    0 returned 2
        -:  803:
        -:  804:    // 2. Left-Up Exceed: (Left Exceeds, Up Exceeds)
        -:  805:    // Using UINT32_MAX to represent -1 in unsigned arithmetic
        2:  806:    check_decode_boundary("2. Left-Up Exceed", dummy_data, UINT32_MAX, UINT32_MAX, 10, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  807:
        -:  808:    // 3. Right-Up Limit: 90, 0, 100, 10 (Valid)
        2:  809:    check_decode_boundary("3. Right-Up Limit", dummy_data, 90, 0, 100, 10, ERR_DECODE);
call    0 returned 2
        -:  810:
        -:  811:    // 4. Right-Up Exceed: (Right Exceeds, Up Exceeds)
        2:  812:    check_decode_boundary("4. Right-Up Exceed", dummy_data, 90, UINT32_MAX, 101, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  813:
        -:  814:    // 5. Left-Down Limit: 0, 90, 10, 100 (Valid)
        2:  815:    check_decode_boundary("5. Left-Down Limit", dummy_data, 0, 90, 10, 100, ERR_DECODE);
call    0 returned 2
        -:  816:
        -:  817:    // 6. Left-Down Exceed: (Left Exceeds, Down Exceeds)
        2:  818:    check_decode_boundary("6. Left-Down Exceed", dummy_data, UINT32_MAX, 90, 10, 101, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  819:
        -:  820:    // 7. Right-Down Limit: 90, 90, 100, 100 (Valid)
        2:  821:    check_decode_boundary("7. Right-Down Limit", dummy_data, 90, 90, 100, 100, ERR_DECODE);
call    0 returned 2
        -:  822:
        -:  823:    // 8. Right-Down Exceed: (Right Exceeds, Down Exceeds)
        2:  824:    check_decode_boundary("8. Right-Down Exceed", dummy_data, 90, 90, 101, 101, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  825:
        -:  826:    // 9. Top Limit (y0=0), Left Exceed (x0 < 0)
        2:  827:    check_decode_boundary("9. Top Limit, Left Exceed", dummy_data, UINT32_MAX, 0, 10, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  828:
        -:  829:    // 10. Top Limit (y0=0), Right Exceed (x1 > 100)
        2:  830:    check_decode_boundary("10. Top Limit, Right Exceed", dummy_data, 90, 0, 101, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  831:
        -:  832:    // 11. Bottom Limit (y1=100), Left Exceed (x0 < 0)
        2:  833:    check_decode_boundary("11. Bottom Limit, Left Exceed", dummy_data, UINT32_MAX, 90, 10, 100, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  834:
        -:  835:    // 12. Bottom Limit (y1=100), Right Exceed (x1 > 100)
        2:  836:    check_decode_boundary("12. Bottom Limit, Right Exceed", dummy_data, 90, 90, 101, 100, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  837:
        -:  838:    // 13. Left Limit (x0=0), Top Exceed (y0 < 0)
        2:  839:    check_decode_boundary("13. Left Limit, Top Exceed", dummy_data, 0, UINT32_MAX, 10, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  840:
        -:  841:    // 14. Left Limit (x0=0), Bottom Exceed (y1 > 100)
        2:  842:    check_decode_boundary("14. Left Limit, Bottom Exceed", dummy_data, 0, 90, 10, 101, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  843:
        -:  844:    // 15. Right Limit (x1=100), Top Exceed (y0 < 0)
        2:  845:    check_decode_boundary("15. Right Limit, Top Exceed", dummy_data, 90, UINT32_MAX, 100, 10, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  846:
        -:  847:    // 16. Right Limit (x1=100), Bottom Exceed (y1 > 100)
        2:  848:    check_decode_boundary("16. Right Limit, Bottom Exceed", dummy_data, 90, 90, 100, 101, ERR_REGION_OUT_OF_BOUNDS);
call    0 returned 2
        -:  849:
        2:  850:    printf("Detailed Boundaries Passed.\n");
call    0 returned 2
        2:  851:    stub_should_header_succeed = 0;
        2:  852:}
        -:  853:
function main called 2 returned 100% blocks executed 100%
        2:  854:int main() {
        2:  855:    test_argb8888();
        2:  855-block  0
call    0 returned 2
        2:  856:    test_rgb565();
call    0 returned 2
        2:  857:    test_grayscale();
call    0 returned 2
        2:  858:    test_grayscale_alpha();
call    0 returned 2
        2:  859:    test_multichannel();
call    0 returned 2
        2:  860:    test_input_validation();
call    0 returned 2
        2:  861:    test_getSize();
call    0 returned 2
        2:  862:    test_decode_failures();
call    0 returned 2
        2:  863:    test_bounds_check();
call    0 returned 2
        2:  864:    test_getsize_failures();
call    0 returned 2
        2:  865:    test_ratio_decode();
call    0 returned 2
        2:  866:    test_jp2_signature();
call    0 returned 2
        2:  867:    test_pixel_limit();
call    0 returned 2
        2:  868:    test_full_decode_success();
call    0 returned 2
        2:  869:    test_detailed_boundaries();
call    0 returned 2
        -:  870:
        -:  871:    // New tests
        2:  872:    test_getLastError();
call    0 returned 2
        2:  873:    test_opj_read_from_buffer();
call    0 returned 2
        2:  874:    test_set_decode_area_failure();
call    0 returned 2
        2:  875:    test_pixel_limit_decode_failure();
call    0 returned 2
        2:  876:    test_pixel_limit_partial_decode_failure();
call    0 returned 2
        2:  877:    test_conversion_failures();
call    0 returned 2
        2:  878:    test_ratio_decode_success();
call    0 returned 2
        2:  879:    test_getSize_decoder_failure();
call    0 returned 2
        -:  880:
        2:  881:    return 0;
unconditional  0 taken 2
        -:  882:}
